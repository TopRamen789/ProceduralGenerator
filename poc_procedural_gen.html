<html>
<head>
<title>poc_procedural_gen</title>
<style>
	.room {
		border-style: solid;
		border-width: 1px;
		border-radius: 1px;
		width: 25px;
		height: 25px;
	}

	.selected {
		background-color: black;
		border-color: white;
		color: white;
	}

	.start {
		background-color: green;
	}
</style>
</head>
<body>
	<span>
		Size X
		<input type='text' id='sizeX' />
		Size Y
		<input type='text' id='sizeY' />
		<button onclick="generatePath()">Generate Path!</button>
	</span>
	<div id="rooms" />
</body>
<script type='text/javascript'>
	function getInputs() {
		let x = document.querySelector('#sizeX').value;
		let y = document.querySelector('#sizeY').value;
		return { x, y };
	}

	function buildContainer() {
		let container = document.createElement('div');
		container.style = 'display: flex';
		return container;
	}

	function buildRoom(parent, x, y) {
		let room = document.createElement('div');
		room.classList.add('room');
		room.id = 'room' + x + '_' + y;
		room.x = x;
		room.y = y;
		room.textContent = x + '_' + y;
		room.isChosen = false;
		parent.appendChild(room);
	}

	function buildRooms() {
		let rooms = document.querySelector('#rooms');
		while(rooms.children.length > 0) {
			let child = rooms.firstChild;
			rooms.removeChild(child);
		}
		let scopeSize = getInputs();
		for(let x = 0; x < scopeSize.x; x++) {
			let parentDiv = buildContainer();
			for(let y = 0; y < scopeSize.y; y++)
				buildRoom(parentDiv, x, y);
			rooms.appendChild(parentDiv);
		}
	}

	/* 
	our generation algorithm is going to make a path randomly from one side of the map to the other.
	*/
	var mapDirection = false;
	var size = {x: 0, y: 0};

	function setInitialDirection() {
		mapDirection = getRandomBoolean();
	}

	function setSize() {
		size = getInputs();
		size.x -= 1;
		size.y -= 1;
	}

	function getSizeRandom() {
		return Math.floor(Math.random() * (mapDirection ? size.x : size.y));
	}

	function getRandomBoolean() {
		return Math.random() > 0.5;
	}

	function buildSelector(x, y) {
		return `#room${x}_${y}`;
	}

	function pickStart() {
		let random = getSizeRandom();
		let params = mapDirection ? [0,random] : [random,0];
		let selector = buildSelector(...params);
		element = document.querySelector(selector);
		element.isChosen = true;
		element.classList.add('start');
		return element;
	}

	function shuffle(array) {
		var currentIndex = array.length, temporaryValue, randomIndex;

		// While there remain elements to shuffle...
		while (0 !== currentIndex) {
			// Pick a remaining element...
			randomIndex = Math.floor(Math.random() * currentIndex);
			currentIndex -= 1;

			// And swap it with the current element.
			temporaryValue = array[currentIndex];
			array[currentIndex] = array[randomIndex];
			array[randomIndex] = temporaryValue;
		}

		return array;
	}

	function generatePath() {
		buildRooms();
		setSize();
		setInitialDirection();
		let current = pickStart();
		let selectedNeighbor;
		do {
			current = selectedNeighbor != null ? {...selectedNeighbor} : current;
			neighbors = getFreeNeighbors(current);
			selectedNeighbor = shuffle(neighbors).pop();
			selectedNeighbor.isChosen = true;
			selectedNeighbor.classList.add('selected');
		} while(neighbors.length > 0);
	}

	function getRooms() {
		return Array.prototype.slice.call(document.querySelector('#rooms').childNodes)
			.reduce((arr, node) => arr.concat(Array.prototype.slice.call(node.childNodes)), []);
	}

	function getDirectNeighbors(currentNode) {
		let min = 1;
		let max = 1;
		return getRooms().filter(room => 
				(currentNode.x-min === room.x && currentNode.y === room.y)
			 || (currentNode.x+max === room.x && currentNode.y === room.y)
			 || (currentNode.y-min === room.y && currentNode.x === room.x)
			 || (currentNode.y+max === room.y && currentNode.x === room.x));
	}

	function getFreeNeighbors(currentNode) {
		let range = 2;
		let freeNeighbors = 
			getDirectNeighbors(currentNode) // get direct neighbors, up, down, left, right
			.filter(neighbor => !neighbor.isChosen) // make sure none of those are chosen neighbors
			.filter((neighbor) => { // get neighbors of neighbors and make sure they have at least 2 choosable neighbors
				return getDirectNeighbors(neighbor)
					.filter(neighbor => neighbor.isChosen).length < range;
			})
			.filter((neighbor) => {
				return getDirectNeighbors(neighbor)
					.filter(neighbor => !neighbor.isChosen || neighbor.x === size.x || neighbor.y === size.y || neighbor.x === 0 || neighbor.y === 0).length > 1;
			});
		return freeNeighbors;
	}
</script>
</html>